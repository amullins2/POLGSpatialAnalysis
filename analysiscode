# 🧬 TMA Visium HD Processing Pipeline
# This notebook processes fixed mouse pancreas TMAs from Visium HD slides.
# It runs MicroarrayProcessor to extract core positions,
# uses spaceranger to generate spatial gene expression data,
# and visualizes endocrine gene expression across cores.

# ---
# ## 🔧 1. Setup paths and imports
import os
import subprocess
import json
from MicroarrayProcessor import run as micro_run
import scanpy as sc
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Define your project structure
project_dir = "/your/project/path"  # <-- EDIT THIS
fastq_dir = os.path.join(project_dir, "fastq")
image_dir = os.path.join(project_dir, "images")
micro_out = os.path.join(project_dir, "outputs", "microarray")
space_out = os.path.join(project_dir, "outputs", "spaceranger")
ref_path = os.path.join(project_dir, "reference", "refdata-gex-mm10-2020-A")

tmas = ["TMA1_HE", "TMA2_HE", "TMA3_HE", "TMA4_HE"]  # One image per TMA

os.makedirs(micro_out, exist_ok=True)
os.makedirs(space_out, exist_ok=True)

# ## 🧫 2. Run MicroarrayProcessor per TMA
def run_microarray(tma_name):
    image_path = os.path.join(image_dir, f"{tma_name}.jpg")
    json_path = os.path.join(micro_out, f"{tma_name}.json")
    if not os.path.exists(json_path):
        print(f"🔍 Running MicroarrayProcessor for {tma_name}...")
        micro_run.main(image_path, micro_out, tma_name, 4, 4, 0)
    else:
        print(f"✅ Already processed: {tma_name}")

# Run MicroarrayProcessor for all TMAs
for tma in tmas:
    run_microarray(tma)

# ## 🧬 3. Run spaceranger per TMA
def run_spaceranger(tma_name):
    sample_id = tma_name.replace("_HE", "")
    output_path = os.path.join(space_out, sample_id)
    if os.path.exists(os.path.join(output_path, "outs")):
        print(f"✅ Spaceranger already completed for {sample_id}")
        return

    cmd = f"""
    spaceranger count \\
      --id={sample_id} \\
      --transcriptome={ref_path} \\
      --fastqs={fastq_dir} \\
      --sample={sample_id} \\
      --image={os.path.join(image_dir, f"{tma_name}.jpg")} \\
      --loupe-alignment={os.path.join(micro_out, f"{tma_name}.json")} \\
      --slide=UNUSED \\
      --area=A1 \\
      --localcores=16 \\
      --localmem=64
    """
    subprocess.run(cmd, shell=True, cwd=space_out)

# Run spaceranger for all TMAs
for tma in tmas:
    run_spaceranger(tma)

# ## 🧬 4. Save extracted cores from the alignment .json
def save_cores(tma_name):
    json_path = os.path.join(micro_out, f"{tma_name}.json")
    if not os.path.exists(json_path):
        print(f"❌ Missing: {json_path}")
        return
    with open(json_path, 'r') as f:
        data = json.load(f)
    core_names = [feature['properties']['name'] for feature in data['features']]
    df = pd.DataFrame(core_names, columns=["core_name"])
    df.to_csv(os.path.join(micro_out, f"{tma_name}_cores.csv"), index=False)

# Save cores for each TMA
for tma in tmas:
    save_cores(tma)

# ## 🧬 5. Load spatial data and analyze by condition
def analyze_tma_by_condition(tma_name):
    # Load spatial data for each core
    adata = sc.read_visium(os.path.join(space_out, tma_name, "outs"))
    adata.var_names_make_unique()

    # Annotate conditions for the cores (e.g., wild-type vs Polg^mut)
    if 'WT' in tma_name:
        adata.obs['condition'] = 'wild-type'
    else:
        adata.obs['condition'] = 'Polg^mut'
    
    # Quality Control
    sc.pp.calculate_qc_metrics(adata, inplace=True)
    adata = adata[adata.obs['total_counts'] > 1000, :]
    adata = adata[adata.obs['n_genes_by_counts'] > 300, :]
    adata.var['mt'] = adata.var_names.str.startswith('mt-')
    sc.pp.calculate_qc_metrics(adata, qc_vars=['mt'], inplace=True)
    adata = adata[adata.obs['pct_counts_mt'] < 20, :]

    # Endocrine gene panel
    endocrine_genes = [
        "Ins1", "Ins2", "Pdx1", "Nkx6-1", "Mafa", "Ucn3", "Slc2a2", "Pcsk1", "Pcsk2",
        "Gcg", "Arx", "Mafb", "Slc38a5", "Slc7a2", "Slc7a3", "Calca", "Peg10",
        "Sst", "Hhex", "Rbp4", "Tac1", "Ppy", "Tspan8", "Pyy", "Ghrl"
    ]
    found_genes = [g for g in endocrine_genes if g in adata.var_names]
    print(f"✅ Found {len(found_genes)} of {len(endocrine_genes)} genes.")

    # Normalize, log, PCA
    sc.pp.normalize_total(adata, target_sum=1e4)
    sc.pp.log1p(adata)
    sc.pp.highly_variable_genes(adata, flavor="seurat", n_top_genes=2000)
    adata = adata[:, adata.var.highly_variable]
    sc.pp.scale(adata)
    sc.tl.pca(adata)

    # Neighbors, UMAP, Leiden clustering
    sc.pp.neighbors(adata)
    sc.tl.umap(adata)
    sc.tl.leiden(adata, resolution=0.5)

    # UMAP with markers and clusters
    sc.pl.umap(adata, color=found_genes[:6] + ['leiden'], ncols=4)
    sc.pl.spatial(adata, color=['leiden'], cmap='Set1', size=1.3)

    # Optionally, save UMAP coordinates and clusters to CSV
    export_umap(adata, tma_name)

# Loop over each TMA and analyze by condition
for tma in tmas:
    analyze_tma_by_condition(tma)

# ## 🧬 6. Export UMAP Coordinates and Clusters
def export_umap(adata, tma_name):
    umap_coords = adata.obsm['X_umap']
    leiden_clusters = adata.obs['leiden']
    df = pd.DataFrame(umap_coords, columns=["UMAP1", "UMAP2"])
    df['leiden'] = leiden_clusters
    df.to_csv(os.path.join(space_out, f"{tma_name}_umap_clusters.csv"), index=False)

# ## 🧬 7. (Optional) Generate Heatmaps for Gene Expression Across Cores
def plot_per_core_heatmap(adata, tma_name):
    for core in adata.obs_names:
        adata_core = adata[adata.obs_names == core]
        sc.pl.spatial(adata_core, color='condition', title=f"{core} - {tma_name}", save=f"{tma_name}_{core}_heatmap.png")

# Example of generating heatmaps for all cores (optional)
# plot_per_core_heatmap(adata, "TMA1_HE")
